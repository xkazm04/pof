import type {
  SimulationConfig,
  SimulationResult,
  EconomyFlow,
  EconomyItem,
  EconomyMetrics,
  SupplyDemandPoint,
  ItemRarity,
  ItemCategory,
} from '@/types/economy-simulator';
import { DEFAULT_FAUCETS, DEFAULT_SINKS, DEFAULT_ITEMS, generateXPCurve } from './definitions';

// ── Types ────────────────────────────────────────────────────────────────────

export interface GeneratedFile {
  filename: string;
  language: 'cpp' | 'h';
  content: string;
  description: string;
}

export interface CodeGenResult {
  files: GeneratedFile[];
  generatedAt: string;
  config: SimulationConfig;
}

// ── Philosophy modifiers (mirror simulation-engine.ts) ───────────────────────

const PHILOSOPHY_MODS: Record<string, { faucetMul: number; sinkMul: number; dropMul: number }> = {
  'loot-driven': { faucetMul: 1.2, sinkMul: 0.8, dropMul: 1.3 },
  'scarcity-based': { faucetMul: 0.7, sinkMul: 1.3, dropMul: 0.6 },
  balanced: { faucetMul: 1.0, sinkMul: 1.0, dropMul: 1.0 },
};

// ── Main Entry Point ─────────────────────────────────────────────────────────

export function generateUE5Code(result: SimulationResult): CodeGenResult {
  const { config } = result;
  const mods = PHILOSOPHY_MODS[config.philosophy] ?? PHILOSOPHY_MODS['balanced'];

  // Apply philosophy multipliers to get the calibrated values
  const faucets = DEFAULT_FAUCETS.map((f) => ({
    ...f,
    baseAmount: Math.round(f.baseAmount * mods.faucetMul),
    levelScaling: Math.round(f.levelScaling * mods.faucetMul * 100) / 100,
  }));
  const sinks = DEFAULT_SINKS.map((f) => ({
    ...f,
    baseAmount: Math.round(f.baseAmount * mods.sinkMul),
    levelScaling: Math.round(f.levelScaling * mods.sinkMul * 100) / 100,
  }));
  const items = DEFAULT_ITEMS.map((it) => ({
    ...it,
    dropWeight: Math.round(it.dropWeight * mods.dropMul * 100) / 100,
  }));

  const xpCurve = generateXPCurve(config.maxLevel);

  return {
    files: [
      generateEconomyConfigHeader(config, faucets, sinks, items, xpCurve),
      generateEconomyConfigSource(config),
      generateEconomyManagerHeader(config, result),
      generateEconomyManagerSource(config, result),
      generateBlueprintLibraryHeader(config, items),
      generateBlueprintLibrarySource(config, items),
      generateGameplayTagsHeader(faucets, sinks),
    ],
    generatedAt: new Date().toISOString(),
    config,
  };
}

// ── Helpers ──────────────────────────────────────────────────────────────────

function toUpperSnake(s: string): string {
  return s.replace(/[^a-zA-Z0-9]/g, '_').toUpperCase();
}

function toPascalCase(s: string): string {
  return s
    .split(/[-_ ]+/)
    .map((w) => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase())
    .join('');
}

function header(filename: string, desc: string): string {
  return `// ${filename}
// Auto-generated by POF Economy Simulator Code Generator
// ${desc}
// Generated: ${new Date().toISOString()}
// DO NOT EDIT — regenerate from simulation results
`;
}

function rarityToEnum(r: ItemRarity): string {
  const map: Record<ItemRarity, string> = {
    common: 'EItemRarity::Common',
    uncommon: 'EItemRarity::Uncommon',
    rare: 'EItemRarity::Rare',
    epic: 'EItemRarity::Epic',
    legendary: 'EItemRarity::Legendary',
  };
  return map[r] ?? 'EItemRarity::Common';
}

function categoryToEnum(c: ItemCategory): string {
  return `EItemCategory::${toPascalCase(c)}`;
}

// ── 1. UEconomyConfig Header ─────────────────────────────────────────────────

function generateEconomyConfigHeader(
  config: SimulationConfig,
  faucets: EconomyFlow[],
  sinks: EconomyFlow[],
  items: EconomyItem[],
  xpCurve: { level: number; xpRequired: number; cumulativeXP: number }[],
): GeneratedFile {
  const content = `${header('EconomyConfig.h', 'UDataAsset holding calibrated economy parameters')}
#pragma once

#include "CoreMinimal.h"
#include "Engine/DataAsset.h"
#include "GameplayTagContainer.h"
#include "EconomyConfig.generated.h"

// ── Enums ────────────────────────────────────────────────────────────────────

UENUM(BlueprintType)
enum class EItemRarity : uint8
{
	Common     UMETA(DisplayName = "Common"),
	Uncommon   UMETA(DisplayName = "Uncommon"),
	Rare       UMETA(DisplayName = "Rare"),
	Epic       UMETA(DisplayName = "Epic"),
	Legendary  UMETA(DisplayName = "Legendary")
};

UENUM(BlueprintType)
enum class EItemCategory : uint8
{
	Weapon     UMETA(DisplayName = "Weapon"),
	Armor      UMETA(DisplayName = "Armor"),
	Consumable UMETA(DisplayName = "Consumable"),
	Material   UMETA(DisplayName = "Material"),
	Gem        UMETA(DisplayName = "Gem"),
	Recipe     UMETA(DisplayName = "Recipe")
};

UENUM(BlueprintType)
enum class EEconomyFlowType : uint8
{
	Faucet UMETA(DisplayName = "Faucet (Gold Source)"),
	Sink   UMETA(DisplayName = "Sink (Gold Drain)")
};

// ── Structs ──────────────────────────────────────────────────────────────────

USTRUCT(BlueprintType)
struct FEconomyFlow
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	FName FlowId;

	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	FText DisplayName;

	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	EEconomyFlowType FlowType = EEconomyFlowType::Faucet;

	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	FGameplayTag CategoryTag;

	/** Base gold amount per occurrence */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, meta = (ClampMin = "0"))
	int32 BaseAmount = 0;

	/** Gold added per player level */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, meta = (ClampMin = "0"))
	float LevelScaling = 0.f;

	/** Average occurrences per hour of play */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, meta = (ClampMin = "0"))
	float FrequencyPerHour = 0.f;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, meta = (ClampMin = "1"))
	int32 MinLevel = 1;

	/** 0 = uncapped */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, meta = (ClampMin = "0"))
	int32 MaxLevel = 0;

	/** Calculate gold amount for a given player level */
	int32 GetAmountForLevel(int32 PlayerLevel) const
	{
		return BaseAmount + FMath::RoundToInt(LevelScaling * PlayerLevel);
	}
};

USTRUCT(BlueprintType)
struct FLootTableEntry
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	FName ItemId;

	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	FText DisplayName;

	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	EItemCategory Category = EItemCategory::Weapon;

	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	EItemRarity Rarity = EItemRarity::Common;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, meta = (ClampMin = "0"))
	int32 BuyPrice = 0;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, meta = (ClampMin = "0"))
	int32 SellPrice = 0;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, meta = (ClampMin = "0"))
	float LevelScaling = 0.f;

	/** Drop weight (higher = more common in loot tables) */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, meta = (ClampMin = "0"))
	float DropWeight = 0.f;

	UPROPERTY(EditAnywhere, BlueprintReadOnly, meta = (ClampMin = "1"))
	int32 MinLevel = 1;

	int32 GetBuyPriceForLevel(int32 PlayerLevel) const
	{
		return BuyPrice + FMath::RoundToInt(LevelScaling * PlayerLevel);
	}

	int32 GetSellPriceForLevel(int32 PlayerLevel) const
	{
		return SellPrice + FMath::RoundToInt(LevelScaling * 0.3f * PlayerLevel);
	}
};

USTRUCT(BlueprintType)
struct FXPCurveEntry
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	int32 Level = 1;

	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	int32 XPRequired = 0;

	UPROPERTY(EditAnywhere, BlueprintReadOnly)
	int32 CumulativeXP = 0;
};

// ── UDataAsset ───────────────────────────────────────────────────────────────

UCLASS(BlueprintType)
class UEconomyConfig : public UDataAsset
{
	GENERATED_BODY()

public:
	// ── Simulation Parameters ────────────────────────────────────────────

	/** Economy philosophy used during calibration */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Simulation")
	FString Philosophy = TEXT("${config.philosophy}");

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Simulation")
	int32 MaxLevel = ${config.maxLevel};

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Simulation")
	int32 SimulatedAgentCount = ${config.agentCount};

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Simulation")
	int32 SimulatedPlayHours = ${config.maxPlayHours};

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Simulation")
	int32 SimulationSeed = ${config.seed};

	// ── Gold Faucets ─────────────────────────────────────────────────────

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Gold|Faucets")
	TArray<FEconomyFlow> Faucets;

	// ── Gold Sinks ───────────────────────────────────────────────────────

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Gold|Sinks")
	TArray<FEconomyFlow> Sinks;

	// ── Loot Table ───────────────────────────────────────────────────────

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Loot")
	TArray<FLootTableEntry> LootTable;

	// ── XP Curve ─────────────────────────────────────────────────────────

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Progression")
	TArray<FXPCurveEntry> XPCurve;

	// ── Helpers ──────────────────────────────────────────────────────────

	/** Get all faucets/sinks by flow type */
	UFUNCTION(BlueprintCallable, Category = "Economy")
	TArray<FEconomyFlow> GetFlowsByType(EEconomyFlowType Type) const;

	/** Get loot entries for a given category and level range */
	UFUNCTION(BlueprintCallable, Category = "Economy")
	TArray<FLootTableEntry> GetLootForCategoryAndLevel(EItemCategory Category, int32 PlayerLevel) const;

	/** Get XP required for a specific level */
	UFUNCTION(BlueprintCallable, Category = "Economy")
	int32 GetXPForLevel(int32 Level) const;
};
`;

  return {
    filename: 'EconomyConfig.h',
    language: 'h',
    content,
    description: 'UDataAsset header with calibrated economy parameters, faucets, sinks, loot tables, and XP curve',
  };
}

// ── 2. UEconomyConfig Source ─────────────────────────────────────────────────

function generateEconomyConfigSource(config: SimulationConfig): GeneratedFile {
  const content = `${header('EconomyConfig.cpp', 'UDataAsset implementation')}
#include "EconomyConfig.h"

TArray<FEconomyFlow> UEconomyConfig::GetFlowsByType(EEconomyFlowType Type) const
{
	TArray<FEconomyFlow> Result;
	const TArray<FEconomyFlow>& Source = (Type == EEconomyFlowType::Faucet) ? Faucets : Sinks;
	for (const FEconomyFlow& Flow : Source)
	{
		Result.Add(Flow);
	}
	return Result;
}

TArray<FLootTableEntry> UEconomyConfig::GetLootForCategoryAndLevel(EItemCategory Category, int32 PlayerLevel) const
{
	TArray<FLootTableEntry> Result;
	for (const FLootTableEntry& Entry : LootTable)
	{
		if (Entry.Category == Category && PlayerLevel >= Entry.MinLevel)
		{
			Result.Add(Entry);
		}
	}
	return Result;
}

int32 UEconomyConfig::GetXPForLevel(int32 Level) const
{
	for (const FXPCurveEntry& Entry : XPCurve)
	{
		if (Entry.Level == Level)
		{
			return Entry.XPRequired;
		}
	}
	return 0;
}
`;

  return {
    filename: 'EconomyConfig.cpp',
    language: 'cpp',
    content,
    description: 'UDataAsset implementation with query helpers for flows, loot, and XP',
  };
}

// ── 3. UEconomyManager Header ────────────────────────────────────────────────

function generateEconomyManagerHeader(
  config: SimulationConfig,
  result: SimulationResult,
): GeneratedFile {
  const lastMetric = result.metrics[result.metrics.length - 1];
  const avgEndGold = lastMetric?.avgGold ?? 0;
  const endGini = lastMetric?.giniCoefficient ?? 0;
  const critAlerts = result.alerts.filter((a) => a.severity === 'critical').length;

  const content = `${header('EconomyManager.h', 'Runtime economy manager with inflation monitoring')}
#pragma once

#include "CoreMinimal.h"
#include "Subsystems/GameInstanceSubsystem.h"
#include "EconomyConfig.h"
#include "EconomyManager.generated.h"

// ── Delegates ────────────────────────────────────────────────────────────────

DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnInflationDetected, float, NetFlowPerHour, float, GiniCoefficient);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnDeflationDetected, float, NetFlowPerHour, int32, AverageGold);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnWealthInequalityAlert, float, GiniCoefficient);

/**
 * UEconomyManager — Runtime economy subsystem
 *
 * Calibrated from simulation:
 *   - ${config.agentCount} agents × ${config.maxPlayHours}h, philosophy: ${config.philosophy}
 *   - Expected endgame avg gold: ${avgEndGold}
 *   - Calibrated Gini: ${endGini}
 *   - Critical alerts in simulation: ${critAlerts}
 */
UCLASS(BlueprintType)
class UEconomyManager : public UGameInstanceSubsystem
{
	GENERATED_BODY()

public:
	virtual void Initialize(FSubsystemCollectionBase& Collection) override;

	// ── Config ───────────────────────────────────────────────────────────

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Economy")
	TSoftObjectPtr<UEconomyConfig> EconomyConfigAsset;

	// ── Runtime Tracking ─────────────────────────────────────────────────

	/** Total gold in circulation across all players */
	UPROPERTY(BlueprintReadOnly, Category = "Economy|Metrics")
	int64 TotalGoldInCirculation = 0;

	/** Gold entering the economy this monitoring window */
	UPROPERTY(BlueprintReadOnly, Category = "Economy|Metrics")
	int64 WindowGoldInflow = 0;

	/** Gold leaving the economy this monitoring window */
	UPROPERTY(BlueprintReadOnly, Category = "Economy|Metrics")
	int64 WindowGoldOutflow = 0;

	/** Current estimated Gini coefficient */
	UPROPERTY(BlueprintReadOnly, Category = "Economy|Metrics")
	float CurrentGini = 0.f;

	// ── Inflation Thresholds (from simulation) ───────────────────────────

	/** Net flow threshold to trigger inflation alert (gold/hr) */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Economy|Thresholds")
	float InflationThreshold = ${Math.round((lastMetric?.outflowPerHour ?? 1000) * 2)}.f;

	/** Gini threshold to trigger inequality alert */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Economy|Thresholds")
	float GiniAlertThreshold = 0.6f;

	/** Expected average gold at endgame (calibrated) */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Economy|Thresholds")
	int32 ExpectedEndgameGold = ${avgEndGold};

	// ── Events ───────────────────────────────────────────────────────────

	UPROPERTY(BlueprintAssignable, Category = "Economy|Events")
	FOnInflationDetected OnInflationDetected;

	UPROPERTY(BlueprintAssignable, Category = "Economy|Events")
	FOnDeflationDetected OnDeflationDetected;

	UPROPERTY(BlueprintAssignable, Category = "Economy|Events")
	FOnWealthInequalityAlert OnWealthInequalityAlert;

	// ── API ──────────────────────────────────────────────────────────────

	/** Call when gold enters the economy (faucet: kill, quest, etc.) */
	UFUNCTION(BlueprintCallable, Category = "Economy")
	void ReportGoldFaucet(FName FlowId, int32 Amount, int32 PlayerLevel);

	/** Call when gold leaves the economy (sink: purchase, repair, etc.) */
	UFUNCTION(BlueprintCallable, Category = "Economy")
	void ReportGoldSink(FName FlowId, int32 Amount, int32 PlayerLevel);

	/** Calculate gold for a faucet at given level */
	UFUNCTION(BlueprintCallable, Category = "Economy")
	int32 CalculateFaucetGold(FName FlowId, int32 PlayerLevel) const;

	/** Calculate cost for a sink at given level */
	UFUNCTION(BlueprintCallable, Category = "Economy")
	int32 CalculateSinkCost(FName FlowId, int32 PlayerLevel) const;

	/** Roll a loot drop for given level and optional category filter */
	UFUNCTION(BlueprintCallable, Category = "Economy")
	FLootTableEntry RollLootDrop(int32 PlayerLevel, EItemCategory CategoryFilter) const;

	/** Force a health check and fire events if thresholds are exceeded */
	UFUNCTION(BlueprintCallable, Category = "Economy")
	void RunInflationCheck();

	/** Reset the monitoring window (call on a timer, e.g., every 5 minutes) */
	UFUNCTION(BlueprintCallable, Category = "Economy")
	void ResetMonitoringWindow();

	/** Update Gini with current player gold values */
	UFUNCTION(BlueprintCallable, Category = "Economy")
	void UpdateGini(const TArray<int32>& PlayerGolds);

private:
	UPROPERTY()
	TObjectPtr<UEconomyConfig> LoadedConfig;

	void LoadConfig();
};
`;

  return {
    filename: 'EconomyManager.h',
    language: 'h',
    content,
    description: 'Runtime economy manager with inflation monitoring, faucet/sink tracking, and loot rolling',
  };
}

// ── 4. UEconomyManager Source ────────────────────────────────────────────────

function generateEconomyManagerSource(
  config: SimulationConfig,
  result: SimulationResult,
): GeneratedFile {
  const content = `${header('EconomyManager.cpp', 'Runtime economy manager implementation')}
#include "EconomyManager.h"

void UEconomyManager::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);
	LoadConfig();
}

void UEconomyManager::LoadConfig()
{
	if (!EconomyConfigAsset.IsNull())
	{
		LoadedConfig = EconomyConfigAsset.LoadSynchronous();
	}
}

void UEconomyManager::ReportGoldFaucet(FName FlowId, int32 Amount, int32 PlayerLevel)
{
	TotalGoldInCirculation += Amount;
	WindowGoldInflow += Amount;
}

void UEconomyManager::ReportGoldSink(FName FlowId, int32 Amount, int32 PlayerLevel)
{
	TotalGoldInCirculation -= Amount;
	if (TotalGoldInCirculation < 0) TotalGoldInCirculation = 0;
	WindowGoldOutflow += Amount;
}

int32 UEconomyManager::CalculateFaucetGold(FName FlowId, int32 PlayerLevel) const
{
	if (!LoadedConfig) return 0;
	for (const FEconomyFlow& Flow : LoadedConfig->Faucets)
	{
		if (Flow.FlowId == FlowId)
		{
			return Flow.GetAmountForLevel(PlayerLevel);
		}
	}
	return 0;
}

int32 UEconomyManager::CalculateSinkCost(FName FlowId, int32 PlayerLevel) const
{
	if (!LoadedConfig) return 0;
	for (const FEconomyFlow& Flow : LoadedConfig->Sinks)
	{
		if (Flow.FlowId == FlowId)
		{
			return Flow.GetAmountForLevel(PlayerLevel);
		}
	}
	return 0;
}

FLootTableEntry UEconomyManager::RollLootDrop(int32 PlayerLevel, EItemCategory CategoryFilter) const
{
	FLootTableEntry EmptyEntry;
	if (!LoadedConfig) return EmptyEntry;

	// Build eligible pool
	TArray<const FLootTableEntry*> Pool;
	float TotalWeight = 0.f;

	for (const FLootTableEntry& Entry : LoadedConfig->LootTable)
	{
		if (PlayerLevel >= Entry.MinLevel && Entry.Category == CategoryFilter)
		{
			Pool.Add(&Entry);
			TotalWeight += Entry.DropWeight;
		}
	}

	if (Pool.Num() == 0 || TotalWeight <= 0.f) return EmptyEntry;

	// Weighted random roll
	float Roll = FMath::FRandRange(0.f, TotalWeight);
	for (const FLootTableEntry* Entry : Pool)
	{
		Roll -= Entry->DropWeight;
		if (Roll <= 0.f)
		{
			return *Entry;
		}
	}

	return *Pool.Last();
}

void UEconomyManager::RunInflationCheck()
{
	const float NetFlow = static_cast<float>(WindowGoldInflow) - static_cast<float>(WindowGoldOutflow);

	// Inflation check
	if (NetFlow > InflationThreshold)
	{
		OnInflationDetected.Broadcast(NetFlow, CurrentGini);
	}

	// Deflation check
	if (NetFlow < -InflationThreshold * 0.5f)
	{
		const int32 AvgGold = TotalGoldInCirculation > 0 ? static_cast<int32>(TotalGoldInCirculation) : 0;
		OnDeflationDetected.Broadcast(NetFlow, AvgGold);
	}

	// Gini check
	if (CurrentGini > GiniAlertThreshold)
	{
		OnWealthInequalityAlert.Broadcast(CurrentGini);
	}
}

void UEconomyManager::ResetMonitoringWindow()
{
	WindowGoldInflow = 0;
	WindowGoldOutflow = 0;
}

void UEconomyManager::UpdateGini(const TArray<int32>& PlayerGolds)
{
	const int32 N = PlayerGolds.Num();
	if (N == 0) { CurrentGini = 0.f; return; }

	TArray<int32> Sorted = PlayerGolds;
	Sorted.Sort();

	int64 Total = 0;
	for (int32 G : Sorted) Total += G;
	if (Total == 0) { CurrentGini = 0.f; return; }

	int64 SumOfDiffs = 0;
	for (int32 i = 0; i < N; i++)
	{
		SumOfDiffs += (2 * (i + 1) - N - 1) * static_cast<int64>(Sorted[i]);
	}

	CurrentGini = static_cast<float>(SumOfDiffs) / static_cast<float>(N * Total);
}
`;

  return {
    filename: 'EconomyManager.cpp',
    language: 'cpp',
    content,
    description: 'Economy manager with faucet/sink reporting, weighted loot rolling, Gini computation, and inflation monitoring',
  };
}

// ── 5. Blueprint Function Library Header ─────────────────────────────────────

function generateBlueprintLibraryHeader(
  config: SimulationConfig,
  items: EconomyItem[],
): GeneratedFile {
  const content = `${header('EconomyBlueprintLibrary.h', 'Blueprint function library for economy queries')}
#pragma once

#include "CoreMinimal.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "EconomyConfig.h"
#include "EconomyBlueprintLibrary.generated.h"

/**
 * Static Blueprint helpers for querying the economy.
 * Calibrated for ${config.philosophy} philosophy, max level ${config.maxLevel}.
 */
UCLASS()
class UEconomyBlueprintLibrary : public UBlueprintFunctionLibrary
{
	GENERATED_BODY()

public:
	/** Get all loot entries available at a player's level */
	UFUNCTION(BlueprintCallable, Category = "Economy|Loot", meta = (WorldContext = "WorldContextObject"))
	static TArray<FLootTableEntry> GetAvailableLoot(
		const UObject* WorldContextObject,
		int32 PlayerLevel);

	/** Get loot filtered by category */
	UFUNCTION(BlueprintCallable, Category = "Economy|Loot", meta = (WorldContext = "WorldContextObject"))
	static TArray<FLootTableEntry> GetLootByCategory(
		const UObject* WorldContextObject,
		EItemCategory Category,
		int32 PlayerLevel);

	/** Get loot filtered by rarity */
	UFUNCTION(BlueprintCallable, Category = "Economy|Loot", meta = (WorldContext = "WorldContextObject"))
	static TArray<FLootTableEntry> GetLootByRarity(
		const UObject* WorldContextObject,
		EItemRarity MinRarity,
		int32 PlayerLevel);

	/** Roll N random drops from the loot table */
	UFUNCTION(BlueprintCallable, Category = "Economy|Loot", meta = (WorldContext = "WorldContextObject"))
	static TArray<FLootTableEntry> RollMultipleDrops(
		const UObject* WorldContextObject,
		int32 PlayerLevel,
		int32 Count);

	/** Calculate total expected gold income per hour at a given level */
	UFUNCTION(BlueprintPure, Category = "Economy|Gold", meta = (WorldContext = "WorldContextObject"))
	static int32 GetExpectedGoldPerHour(
		const UObject* WorldContextObject,
		int32 PlayerLevel);

	/** Calculate total expected gold expenditure per hour at a given level */
	UFUNCTION(BlueprintPure, Category = "Economy|Gold", meta = (WorldContext = "WorldContextObject"))
	static int32 GetExpectedSinkPerHour(
		const UObject* WorldContextObject,
		int32 PlayerLevel);

	/** Get the net gold flow (income - expense) per hour */
	UFUNCTION(BlueprintPure, Category = "Economy|Gold", meta = (WorldContext = "WorldContextObject"))
	static int32 GetNetGoldFlowPerHour(
		const UObject* WorldContextObject,
		int32 PlayerLevel);

	/** Get XP required for a specific level */
	UFUNCTION(BlueprintPure, Category = "Economy|Progression", meta = (WorldContext = "WorldContextObject"))
	static int32 GetXPRequiredForLevel(
		const UObject* WorldContextObject,
		int32 Level);

	/** Check if a player can afford an item at their level */
	UFUNCTION(BlueprintPure, Category = "Economy|Loot")
	static bool CanAffordItem(const FLootTableEntry& Item, int32 PlayerLevel, int32 CurrentGold);

private:
	static UEconomyManager* GetManager(const UObject* WorldContextObject);
};
`;

  return {
    filename: 'EconomyBlueprintLibrary.h',
    language: 'h',
    content,
    description: 'Blueprint-callable static functions for loot queries, gold calculations, and XP lookups',
  };
}

// ── 6. Blueprint Function Library Source ─────────────────────────────────────

function generateBlueprintLibrarySource(
  config: SimulationConfig,
  items: EconomyItem[],
): GeneratedFile {
  const content = `${header('EconomyBlueprintLibrary.cpp', 'Blueprint function library implementation')}
#include "EconomyBlueprintLibrary.h"
#include "EconomyManager.h"

UEconomyManager* UEconomyBlueprintLibrary::GetManager(const UObject* WorldContextObject)
{
	if (!WorldContextObject) return nullptr;
	UGameInstance* GI = WorldContextObject->GetWorld()->GetGameInstance();
	return GI ? GI->GetSubsystem<UEconomyManager>() : nullptr;
}

TArray<FLootTableEntry> UEconomyBlueprintLibrary::GetAvailableLoot(
	const UObject* WorldContextObject, int32 PlayerLevel)
{
	TArray<FLootTableEntry> Result;
	UEconomyManager* Mgr = GetManager(WorldContextObject);
	if (!Mgr || !Mgr->EconomyConfigAsset.IsValid()) return Result;

	UEconomyConfig* Config = Mgr->EconomyConfigAsset.Get();
	for (const FLootTableEntry& Entry : Config->LootTable)
	{
		if (PlayerLevel >= Entry.MinLevel)
		{
			Result.Add(Entry);
		}
	}
	return Result;
}

TArray<FLootTableEntry> UEconomyBlueprintLibrary::GetLootByCategory(
	const UObject* WorldContextObject, EItemCategory Category, int32 PlayerLevel)
{
	TArray<FLootTableEntry> Result;
	UEconomyManager* Mgr = GetManager(WorldContextObject);
	if (!Mgr || !Mgr->EconomyConfigAsset.IsValid()) return Result;

	UEconomyConfig* Config = Mgr->EconomyConfigAsset.Get();
	for (const FLootTableEntry& Entry : Config->LootTable)
	{
		if (Entry.Category == Category && PlayerLevel >= Entry.MinLevel)
		{
			Result.Add(Entry);
		}
	}
	return Result;
}

TArray<FLootTableEntry> UEconomyBlueprintLibrary::GetLootByRarity(
	const UObject* WorldContextObject, EItemRarity MinRarity, int32 PlayerLevel)
{
	TArray<FLootTableEntry> Result;
	UEconomyManager* Mgr = GetManager(WorldContextObject);
	if (!Mgr || !Mgr->EconomyConfigAsset.IsValid()) return Result;

	UEconomyConfig* Config = Mgr->EconomyConfigAsset.Get();
	for (const FLootTableEntry& Entry : Config->LootTable)
	{
		if (PlayerLevel >= Entry.MinLevel && static_cast<uint8>(Entry.Rarity) >= static_cast<uint8>(MinRarity))
		{
			Result.Add(Entry);
		}
	}
	return Result;
}

TArray<FLootTableEntry> UEconomyBlueprintLibrary::RollMultipleDrops(
	const UObject* WorldContextObject, int32 PlayerLevel, int32 Count)
{
	TArray<FLootTableEntry> Result;
	UEconomyManager* Mgr = GetManager(WorldContextObject);
	if (!Mgr) return Result;

	for (int32 i = 0; i < Count; i++)
	{
		// Roll across all categories
		const int32 CatIndex = FMath::RandRange(0, 4);
		const EItemCategory Categories[] = {
			EItemCategory::Weapon, EItemCategory::Armor, EItemCategory::Consumable,
			EItemCategory::Material, EItemCategory::Gem
		};
		FLootTableEntry Drop = Mgr->RollLootDrop(PlayerLevel, Categories[CatIndex]);
		if (Drop.ItemId != NAME_None)
		{
			Result.Add(Drop);
		}
	}
	return Result;
}

int32 UEconomyBlueprintLibrary::GetExpectedGoldPerHour(
	const UObject* WorldContextObject, int32 PlayerLevel)
{
	UEconomyManager* Mgr = GetManager(WorldContextObject);
	if (!Mgr || !Mgr->EconomyConfigAsset.IsValid()) return 0;

	UEconomyConfig* Config = Mgr->EconomyConfigAsset.Get();
	int32 Total = 0;
	for (const FEconomyFlow& Flow : Config->Faucets)
	{
		if (PlayerLevel >= Flow.MinLevel && (Flow.MaxLevel == 0 || PlayerLevel <= Flow.MaxLevel))
		{
			Total += FMath::RoundToInt(Flow.GetAmountForLevel(PlayerLevel) * Flow.FrequencyPerHour);
		}
	}
	return Total;
}

int32 UEconomyBlueprintLibrary::GetExpectedSinkPerHour(
	const UObject* WorldContextObject, int32 PlayerLevel)
{
	UEconomyManager* Mgr = GetManager(WorldContextObject);
	if (!Mgr || !Mgr->EconomyConfigAsset.IsValid()) return 0;

	UEconomyConfig* Config = Mgr->EconomyConfigAsset.Get();
	int32 Total = 0;
	for (const FEconomyFlow& Flow : Config->Sinks)
	{
		if (PlayerLevel >= Flow.MinLevel && (Flow.MaxLevel == 0 || PlayerLevel <= Flow.MaxLevel))
		{
			Total += FMath::RoundToInt(Flow.GetAmountForLevel(PlayerLevel) * Flow.FrequencyPerHour);
		}
	}
	return Total;
}

int32 UEconomyBlueprintLibrary::GetNetGoldFlowPerHour(
	const UObject* WorldContextObject, int32 PlayerLevel)
{
	return GetExpectedGoldPerHour(WorldContextObject, PlayerLevel)
		- GetExpectedSinkPerHour(WorldContextObject, PlayerLevel);
}

int32 UEconomyBlueprintLibrary::GetXPRequiredForLevel(
	const UObject* WorldContextObject, int32 Level)
{
	UEconomyManager* Mgr = GetManager(WorldContextObject);
	if (!Mgr || !Mgr->EconomyConfigAsset.IsValid()) return 0;

	return Mgr->EconomyConfigAsset.Get()->GetXPForLevel(Level);
}

bool UEconomyBlueprintLibrary::CanAffordItem(const FLootTableEntry& Item, int32 PlayerLevel, int32 CurrentGold)
{
	return CurrentGold >= Item.GetBuyPriceForLevel(PlayerLevel);
}
`;

  return {
    filename: 'EconomyBlueprintLibrary.cpp',
    language: 'cpp',
    content,
    description: 'Static blueprint functions for loot rolling, gold flow estimation, and affordability checks',
  };
}

// ── 7. Gameplay Tags Header ──────────────────────────────────────────────────

function generateGameplayTagsHeader(
  faucets: EconomyFlow[],
  sinks: EconomyFlow[],
): GeneratedFile {
  const faucetTags = faucets.map((f) => {
    const tag = `Economy.Faucet.${toPascalCase(f.category)}.${toPascalCase(f.id)}`;
    return { tag, comment: f.name };
  });

  const sinkTags = sinks.map((f) => {
    const tag = `Economy.Sink.${toPascalCase(f.category)}.${toPascalCase(f.id)}`;
    return { tag, comment: f.name };
  });

  // Category tags
  const faucetCategories = [...new Set(faucets.map((f) => f.category))];
  const sinkCategories = [...new Set(sinks.map((f) => f.category))];

  const content = `${header('EconomyGameplayTags.h', 'Gameplay Tags for economy faucets and sinks')}
#pragma once

#include "NativeGameplayTags.h"

// ── Economy Faucet Category Tags ─────────────────────────────────────────────
${faucetCategories.map((cat) =>
  `UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Economy_Faucet_${toPascalCase(cat)});`
).join('\n')}

// ── Economy Sink Category Tags ───────────────────────────────────────────────
${sinkCategories.map((cat) =>
  `UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Economy_Sink_${toPascalCase(cat)});`
).join('\n')}

// ── Individual Faucet Tags ───────────────────────────────────────────────────
${faucetTags.map(({ tag, comment }) =>
  `UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_${tag.replace(/\./g, '_')}); // ${comment}`
).join('\n')}

// ── Individual Sink Tags ─────────────────────────────────────────────────────
${sinkTags.map(({ tag, comment }) =>
  `UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_${tag.replace(/\./g, '_')}); // ${comment}`
).join('\n')}

// ── Convenience namespace ────────────────────────────────────────────────────

namespace EconomyTags
{
${faucetCategories.map((cat) =>
  `\tconst FGameplayTag& Faucet_${toPascalCase(cat)}();`
).join('\n')}
${sinkCategories.map((cat) =>
  `\tconst FGameplayTag& Sink_${toPascalCase(cat)}();`
).join('\n')}
}

// ── Define tags (include in ONE .cpp file) ───────────────────────────────────
// To register these tags, add the following to your module's .cpp:
//
//   #include "EconomyGameplayTags.h"
//
${faucetCategories.map((cat) =>
  `//   UE_DEFINE_GAMEPLAY_TAG(TAG_Economy_Faucet_${toPascalCase(cat)}, "Economy.Faucet.${toPascalCase(cat)}");`
).join('\n')}
${sinkCategories.map((cat) =>
  `//   UE_DEFINE_GAMEPLAY_TAG(TAG_Economy_Sink_${toPascalCase(cat)}, "Economy.Sink.${toPascalCase(cat)}");`
).join('\n')}
//
${faucetTags.map(({ tag }) =>
  `//   UE_DEFINE_GAMEPLAY_TAG(TAG_${tag.replace(/\./g, '_')}, "${tag}");`
).join('\n')}
${sinkTags.map(({ tag }) =>
  `//   UE_DEFINE_GAMEPLAY_TAG(TAG_${tag.replace(/\./g, '_')}, "${tag}");`
).join('\n')}
`;

  return {
    filename: 'EconomyGameplayTags.h',
    language: 'h',
    content,
    description: 'UE5 Gameplay Tags matching every faucet/sink category for event-driven economy tracking',
  };
}

// ── Default Config Init Data (for DataAsset serialization) ──────────────────

export function generateDataAssetInit(result: SimulationResult): string {
  const { config } = result;
  const mods = PHILOSOPHY_MODS[config.philosophy] ?? PHILOSOPHY_MODS['balanced'];

  const faucets = DEFAULT_FAUCETS.map((f) => ({
    ...f,
    baseAmount: Math.round(f.baseAmount * mods.faucetMul),
    levelScaling: Math.round(f.levelScaling * mods.faucetMul * 100) / 100,
  }));
  const sinks = DEFAULT_SINKS.map((f) => ({
    ...f,
    baseAmount: Math.round(f.baseAmount * mods.sinkMul),
    levelScaling: Math.round(f.levelScaling * mods.sinkMul * 100) / 100,
  }));
  const items = DEFAULT_ITEMS.map((it) => ({
    ...it,
    dropWeight: Math.round(it.dropWeight * mods.dropMul * 100) / 100,
  }));
  const xpCurve = generateXPCurve(config.maxLevel);

  let out = `// ── DataAsset Initialization Snippet ──────────────────────────────────\n`;
  out += `// Paste in your editor's Details panel or use in C++ constructor\n\n`;

  out += `// Faucets:\n`;
  for (const f of faucets) {
    out += `//   { "${f.id}", "${f.name}", Faucet, ${f.baseAmount}, ${f.levelScaling}f, ${f.frequencyPerHour}f, ${f.minLevel}, ${f.maxLevel} }\n`;
  }

  out += `\n// Sinks:\n`;
  for (const f of sinks) {
    out += `//   { "${f.id}", "${f.name}", Sink, ${f.baseAmount}, ${f.levelScaling}f, ${f.frequencyPerHour}f, ${f.minLevel}, ${f.maxLevel} }\n`;
  }

  out += `\n// Loot Table (${items.length} entries):\n`;
  for (const it of items) {
    out += `//   { "${it.id}", "${it.name}", ${it.category}, ${it.rarity}, buy:${it.buyPrice}, sell:${it.sellPrice}, scale:${it.levelScaling}f, weight:${it.dropWeight}, minLvl:${it.minLevel} }\n`;
  }

  out += `\n// XP Curve (${xpCurve.length} levels):\n`;
  for (const x of xpCurve) {
    out += `//   Level ${x.level}: ${x.xpRequired} XP (cumulative: ${x.cumulativeXP})\n`;
  }

  return out;
}
