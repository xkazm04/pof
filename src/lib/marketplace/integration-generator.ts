import type { IntegrationSpec, IntegrationStep, MarketplaceAsset } from '@/types/marketplace';
import { ASSET_CATALOG } from './asset-catalog';

/**
 * Generates C++ integration adapter code that bridges a marketplace asset
 * with the project's existing architecture (GAS, inventory, character systems).
 */
export function generateIntegration(
  assetId: string,
  moduleId: string,
  projectName: string,
  apiMacro: string,
  existingClasses: string[],
): IntegrationSpec | null {
  const asset = ASSET_CATALOG.find((a) => a.id === assetId);
  if (!asset) return null;

  const adapterName = `U${toPascal(projectName)}${toPascal(asset.name.split(' ')[0])}Adapter`;
  const headerGuard = `${projectName.toUpperCase()}_${toPascal(asset.name.split(' ')[0]).toUpperCase()}_ADAPTER_H`;

  const steps: IntegrationStep[] = [];
  const buildDeps: string[] = [];
  const pluginDeps: string[] = [];

  // Determine integration based on asset category
  const { header, source } = generateAdapterCode(
    asset, moduleId, projectName, apiMacro, adapterName, headerGuard, existingClasses,
    steps, buildDeps, pluginDeps,
  );

  return {
    assetId,
    assetName: asset.name,
    moduleId,
    adapterHeader: header,
    adapterSource: source,
    buildDependencies: buildDeps,
    pluginDependencies: pluginDeps,
    steps,
  };
}

function toPascal(s: string): string {
  return s
    .replace(/[^a-zA-Z0-9]/g, ' ')
    .split(/\s+/)
    .map((w) => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase())
    .join('');
}

function generateAdapterCode(
  asset: MarketplaceAsset,
  moduleId: string,
  projectName: string,
  apiMacro: string,
  adapterName: string,
  headerGuard: string,
  existingClasses: string[],
  steps: IntegrationStep[],
  buildDeps: string[],
  pluginDeps: string[],
): { header: string; source: string } {
  // Add common build deps
  buildDeps.push('Core', 'CoreUObject', 'Engine');

  // Generate category-specific code
  if (asset.category === 'combat' && asset.gasCompatible) {
    return generateGASCombatAdapter(asset, projectName, apiMacro, adapterName, headerGuard, existingClasses, steps, buildDeps, pluginDeps);
  }
  if (asset.category === 'inventory') {
    return generateInventoryAdapter(asset, projectName, apiMacro, adapterName, headerGuard, existingClasses, steps, buildDeps, pluginDeps);
  }
  if (asset.category === 'ai') {
    return generateAIAdapter(asset, projectName, apiMacro, adapterName, headerGuard, existingClasses, steps, buildDeps, pluginDeps);
  }

  // Default: generic component adapter
  return generateGenericAdapter(asset, projectName, apiMacro, adapterName, headerGuard, steps, buildDeps, pluginDeps);
}

// ── GAS-compatible combat adapter ────────────────────────────────────────────

function generateGASCombatAdapter(
  asset: MarketplaceAsset,
  projectName: string,
  apiMacro: string,
  adapterName: string,
  headerGuard: string,
  existingClasses: string[],
  steps: IntegrationStep[],
  buildDeps: string[],
  pluginDeps: string[],
): { header: string; source: string } {
  buildDeps.push('GameplayAbilities', 'GameplayTags', 'GameplayTasks');
  pluginDeps.push('GameplayAbilities');

  const hasASC = existingClasses.some((c) => c.includes('AbilitySystem') || c.includes('ASC'));
  const hasCharBase = existingClasses.some((c) => c.includes('CharacterBase'));

  steps.push(
    { order: 1, title: 'Install the asset', description: `Add ${asset.name} to your project via the launcher or extract to Plugins/.` },
    { order: 2, title: 'Add build dependency', description: `Add "${toPascal(asset.name.split(' ')[0])}" to PublicDependencyModuleNames in ${projectName}.Build.cs.` },
    { order: 3, title: 'Create the adapter', description: `Create ${adapterName} in Source/${projectName}/Integration/ to bridge the asset with your GAS setup.` },
    { order: 4, title: 'Initialize in character', description: hasCharBase
      ? 'Add the adapter component to your AARPGCharacterBase::AARPGCharacterBase constructor.'
      : 'Add the adapter component to your character class constructor.' },
    { order: 5, title: 'Build and test', description: 'Compile and verify the integration with a simple test.' },
  );

  const header = `#pragma once

#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "${adapterName}.generated.h"

class UAbilitySystemComponent;

/**
 * Adapter bridging ${asset.name} with the project's GAS architecture.
 * Generated by POF Asset Scout.
 */
UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
class ${apiMacro} ${adapterName} : public UActorComponent
{
    GENERATED_BODY()

public:
    ${adapterName}();

    /** Initialize the adapter with the owning character's ASC */
    UFUNCTION(BlueprintCallable, Category = "Integration")
    void InitializeWithASC(UAbilitySystemComponent* InASC);

    /** Bridge: trigger an ability from the marketplace asset through GAS */
    UFUNCTION(BlueprintCallable, Category = "Integration")
    void ActivateAssetAbility(FGameplayTag AbilityTag);

    /** Bridge: apply a marketplace asset effect through GAS */
    UFUNCTION(BlueprintCallable, Category = "Integration")
    void ApplyAssetEffect(TSubclassOf<UGameplayEffect> EffectClass, float Level = 1.0f);

protected:
    virtual void BeginPlay() override;

private:
    UPROPERTY()
    TObjectPtr<UAbilitySystemComponent> CachedASC;
};
`;

  const source = `#include "Integration/${adapterName}.h"
#include "AbilitySystemComponent.h"
#include "GameplayEffect.h"

${adapterName}::${adapterName}()
{
    PrimaryComponentTick.bCanEverTick = false;
}

void ${adapterName}::BeginPlay()
{
    Super::BeginPlay();

    // Auto-discover ASC on owning actor
    if (!CachedASC)
    {
        CachedASC = GetOwner()->FindComponentByClass<UAbilitySystemComponent>();
    }
}

void ${adapterName}::InitializeWithASC(UAbilitySystemComponent* InASC)
{
    CachedASC = InASC;
}

void ${adapterName}::ActivateAssetAbility(FGameplayTag AbilityTag)
{
    if (!CachedASC) return;

    FGameplayTagContainer Tags;
    Tags.AddTag(AbilityTag);
    CachedASC->TryActivateAbilitiesByTag(Tags);
}

void ${adapterName}::ApplyAssetEffect(TSubclassOf<UGameplayEffect> EffectClass, float Level)
{
    if (!CachedASC || !EffectClass) return;

    FGameplayEffectContextHandle Context = CachedASC->MakeEffectContext();
    Context.AddSourceObject(GetOwner());

    FGameplayEffectSpecHandle Spec = CachedASC->MakeOutgoingSpec(EffectClass, Level, Context);
    if (Spec.IsValid())
    {
        CachedASC->ApplyGameplayEffectSpecToSelf(*Spec.Data.Get());
    }
}
`;

  return { header, source };
}

// ── Inventory adapter ────────────────────────────────────────────────────────

function generateInventoryAdapter(
  asset: MarketplaceAsset,
  projectName: string,
  apiMacro: string,
  adapterName: string,
  headerGuard: string,
  existingClasses: string[],
  steps: IntegrationStep[],
  buildDeps: string[],
  pluginDeps: string[],
): { header: string; source: string } {
  const hasInventoryComp = existingClasses.some((c) => c.includes('Inventory'));

  steps.push(
    { order: 1, title: 'Install the asset', description: `Add ${asset.name} to your project.` },
    { order: 2, title: 'Create item bridge', description: `Create ${adapterName} to convert between the asset's item format and your UARPGItemInstance.` },
    { order: 3, title: 'Wire events', description: 'Connect the asset\'s OnItemAdded/OnItemRemoved delegates to your inventory component delegates.' },
    { order: 4, title: 'Update UI', description: 'Replace or adapt the asset\'s inventory UI to match your game\'s style.' },
    { order: 5, title: 'Test', description: 'Pick up items, open inventory, equip — verify data flows correctly through the adapter.' },
  );

  const header = `#pragma once

#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "${adapterName}.generated.h"

/**
 * Bridges ${asset.name} with the project's inventory system.
 * Converts between marketplace item format and UARPGItemInstance.
 */
UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
class ${apiMacro} ${adapterName} : public UActorComponent
{
    GENERATED_BODY()

public:
    ${adapterName}();

    /** Convert a marketplace item to our native item instance */
    UFUNCTION(BlueprintCallable, Category = "Integration")
    UObject* ConvertToNativeItem(UObject* MarketplaceItem);

    /** Convert our native item instance to marketplace format */
    UFUNCTION(BlueprintCallable, Category = "Integration")
    UObject* ConvertToMarketplaceItem(UObject* NativeItem);

    /** Sync inventory state between systems */
    UFUNCTION(BlueprintCallable, Category = "Integration")
    void SyncInventories();

protected:
    virtual void BeginPlay() override;
};
`;

  const source = `#include "Integration/${adapterName}.h"

${adapterName}::${adapterName}()
{
    PrimaryComponentTick.bCanEverTick = false;
}

void ${adapterName}::BeginPlay()
{
    Super::BeginPlay();
    // TODO: Bind to marketplace asset's delegates
}

UObject* ${adapterName}::ConvertToNativeItem(UObject* MarketplaceItem)
{
    // TODO: Map marketplace item properties to UARPGItemInstance
    // - Name, Icon, Type, Rarity from marketplace data
    // - Generate affixes from marketplace stat modifiers
    return nullptr;
}

UObject* ${adapterName}::ConvertToMarketplaceItem(UObject* NativeItem)
{
    // TODO: Reverse mapping for UI compatibility
    return nullptr;
}

void ${adapterName}::SyncInventories()
{
    // TODO: Reconcile both inventory systems
}
`;

  return { header, source };
}

// ── AI adapter ───────────────────────────────────────────────────────────────

function generateAIAdapter(
  asset: MarketplaceAsset,
  projectName: string,
  apiMacro: string,
  adapterName: string,
  headerGuard: string,
  existingClasses: string[],
  steps: IntegrationStep[],
  buildDeps: string[],
  pluginDeps: string[],
): { header: string; source: string } {
  buildDeps.push('AIModule', 'GameplayTasks');

  steps.push(
    { order: 1, title: 'Install the asset', description: `Add ${asset.name} to your project.` },
    { order: 2, title: 'Create AI bridge', description: `Create ${adapterName} to map between the asset's AI decisions and your behavior tree / GAS abilities.` },
    { order: 3, title: 'Configure perception', description: 'Ensure the asset\'s perception config matches your game\'s sight/damage sense setup.' },
    { order: 4, title: 'Connect abilities', description: 'Wire the asset\'s attack decisions to trigger your GA_EnemyMeleeAttack / GA_EnemyRangedAttack abilities.' },
    { order: 5, title: 'Test with archetypes', description: 'Test each enemy archetype (Grunt, Caster, Brute) with the new AI system.' },
  );

  const header = `#pragma once

#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "${adapterName}.generated.h"

class AAIController;

/**
 * Bridges ${asset.name} with the project's enemy AI and GAS combat.
 */
UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
class ${apiMacro} ${adapterName} : public UActorComponent
{
    GENERATED_BODY()

public:
    ${adapterName}();

    /** Map asset AI decision to a GAS ability activation */
    UFUNCTION(BlueprintCallable, Category = "Integration")
    void ExecuteAIAction(FName ActionName);

    /** Configure perception from asset settings */
    UFUNCTION(BlueprintCallable, Category = "Integration")
    void SyncPerceptionConfig(AAIController* Controller);

protected:
    virtual void BeginPlay() override;
};
`;

  const source = `#include "Integration/${adapterName}.h"
#include "AIController.h"

${adapterName}::${adapterName}()
{
    PrimaryComponentTick.bCanEverTick = false;
}

void ${adapterName}::BeginPlay()
{
    Super::BeginPlay();
}

void ${adapterName}::ExecuteAIAction(FName ActionName)
{
    // TODO: Map ActionName from marketplace asset to:
    // - "Attack" -> TryActivateAbilityByClass(GA_EnemyMeleeAttack)
    // - "Ranged" -> TryActivateAbilityByClass(GA_EnemyRangedAttack)
    // - "Charge" -> TryActivateAbilityByClass(GA_EnemyChargeAttack)
}

void ${adapterName}::SyncPerceptionConfig(AAIController* Controller)
{
    // TODO: Read perception settings from marketplace asset
    // and apply to the controller's UAIPerceptionComponent
}
`;

  return { header, source };
}

// ── Generic adapter ──────────────────────────────────────────────────────────

function generateGenericAdapter(
  asset: MarketplaceAsset,
  projectName: string,
  apiMacro: string,
  adapterName: string,
  headerGuard: string,
  steps: IntegrationStep[],
  buildDeps: string[],
  pluginDeps: string[],
): { header: string; source: string } {
  steps.push(
    { order: 1, title: 'Install the asset', description: `Add ${asset.name} to your project via the launcher or extract to Plugins/.` },
    { order: 2, title: 'Add build dependency', description: `Add the asset's module name to PublicDependencyModuleNames in ${projectName}.Build.cs.` },
    { order: 3, title: 'Create the adapter', description: `Create ${adapterName} in Source/${projectName}/Integration/ to wrap the asset's API.` },
    { order: 4, title: 'Wire to existing systems', description: 'Connect the adapter to your game\'s subsystems as needed.' },
    { order: 5, title: 'Build and test', description: 'Compile and verify everything works together.' },
  );

  const header = `#pragma once

#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "${adapterName}.generated.h"

/**
 * Integration adapter for ${asset.name}.
 * Wraps the marketplace asset's API for use with the project's architecture.
 * Generated by POF Asset Scout.
 */
UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
class ${apiMacro} ${adapterName} : public UActorComponent
{
    GENERATED_BODY()

public:
    ${adapterName}();

    /** Initialize the adapter after the owning actor is ready */
    UFUNCTION(BlueprintCallable, Category = "Integration")
    void InitializeAdapter();

    /** Check if the marketplace asset is properly configured */
    UFUNCTION(BlueprintPure, Category = "Integration")
    bool IsAssetReady() const;

protected:
    virtual void BeginPlay() override;

private:
    bool bIsInitialized = false;
};
`;

  const source = `#include "Integration/${adapterName}.h"

${adapterName}::${adapterName}()
{
    PrimaryComponentTick.bCanEverTick = false;
}

void ${adapterName}::BeginPlay()
{
    Super::BeginPlay();
    InitializeAdapter();
}

void ${adapterName}::InitializeAdapter()
{
    // TODO: Initialize the marketplace asset's components/subsystems
    // and wire them to the project's existing architecture.
    bIsInitialized = true;
}

bool ${adapterName}::IsAssetReady() const
{
    return bIsInitialized;
}
`;

  return { header, source };
}
